ðŸ“˜ Day 22 â€“ Docker Networking (Repo Summary)

Today I learned how Docker networking enables containers to communicate with the host machine and with other containers in a clean, predictable way.

ðŸ”¹ Custom Host Entry (Container â†’ Host Communication)

By default, containers donâ€™t know an easy hostname for the host machine. Using --add-host, we can define a custom DNS entry inside the container.

This avoids hardcoding IP addresses and makes host communication reliable.

Key commands learned:

docker run --add-host <hostname>:<ip> <image>

Using host.docker.internal with host-gateway

Testing connectivity using ping

Example:

docker run --add-host host.docker.internal:host-gateway -it alpine

ping host.docker.internal

ðŸ“Œ This allows containers to access services running on the host machine safely and consistently.

ðŸ”¹ User-Defined Docker Networks (Container â†” Container Communication)

User-defined networks are more powerful than the default bridge network. They allow:

Containers to communicate using container names as hostnames

Automatic DNS resolution

Better isolation and control

Steps learned:

Create a custom network

Run containers attached to that network

Communicate using container names

Example:

docker network create my_network

Run multiple containers with --network my_network

Use ping container-name for communication

ðŸ“Œ Containers on the same user-defined network can talk to each other without IP addresses, using only names.

âœ… Key Takeaway

Docker networking becomes much simpler and more powerful when using:

--add-host for container â†’ host communication

User-defined networks for container â†’ container communication

These concepts are critical for real-world microservices and DevOps setups.